## 学习时间：
	23：00 - 1：00
## 学习内容
* 堆
* 栈
* 冒泡排序
* 堆排序
## 学习计划：
* 复习简单的排序算法
* 复习堆和栈实现的思想
* 思考代码的时间复杂度
## 解决问题：
* 堆的实现及堆排序的实现
* 冒泡排序与堆排序时间复杂度的比较
* 栈的函数的实现
## 学习总结：
#### 堆：
*	一直以来，我用的是stl中的priority_queue优先队列代替堆的作用，
*	这次知道了，实现最小堆，实际就是让二叉树的根结点永远小于子结点。
*	插入新数的过程，就是创立新的子结点，通过不断与根结点比较，交换到合适的位置。
*	删除数据的过程，就是将第一个数替换成最后一个数，总数减少一，通过不断与子结点比较，交换到合适的位置。
#### 栈：
*   一直以来，我用的是stl中的stack，这次手写栈的四个基本函数top(),empty(),push(),pop();
*	栈是后进先出的，所以实际上可以直接对数组进行相应操作，改变末尾的数字指向即可。
*   发现了c++可以将函数写在结构体中，最后通过访问成员实现的效果与平常相同。
#### 冒泡排序：
*   前一个与后一个元素比较，不满足则交换位置
*   每次最后末尾的几个元素可以不比较，因为每次交换完最后元素的顺序已确定
*   时间复杂度是O（n * n)
#### 堆排序：
*   实际上就相当于删除数据的操作，每次将顶端输出
*   时间负杂度O （n * logn）